name: Deploy to AWS

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  DOMAIN: pbradygeorgen.com
  SUBDOMAIN: study
  FULL_DOMAIN: study.pbradygeorgen.com
  S3_BUCKET: study.pbradygeorgen.com

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run linting
      run: npm run lint
      
    - name: Build application
      run: npm run build
      
    - name: Export static files
      run: npm run export
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Deploy to S3
      run: |
        # Create S3 bucket if it doesn't exist
        aws s3api head-bucket --bucket ${{ env.S3_BUCKET }} 2>/dev/null || \
        if [ "${{ env.AWS_REGION }}" = "us-east-1" ]; then
          aws s3api create-bucket \
            --bucket ${{ env.S3_BUCKET }} \
            --region ${{ env.AWS_REGION }}
        else
          aws s3api create-bucket \
            --bucket ${{ env.S3_BUCKET }} \
            --region ${{ env.AWS_REGION }} \
            --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }}
        fi
        
        # Configure bucket for static website hosting
        aws s3api put-bucket-website \
          --bucket ${{ env.S3_BUCKET }} \
          --website-configuration '{
              "IndexDocument": {"Suffix": "index.html"},
              "ErrorDocument": {"Key": "404.html"}
          }'
        
        # Check if bucket has public access blocked
        BLOCK_PUBLIC_ACCESS=$(aws s3api get-public-access-block --bucket ${{ env.S3_BUCKET }} --query 'PublicAccessBlockConfiguration.BlockPublicPolicy' --output text 2>/dev/null || echo "true")
        
        if [ "$BLOCK_PUBLIC_ACCESS" = "false" ]; then
          # Set bucket policy for public read access
          aws s3api put-bucket-policy \
            --bucket ${{ env.S3_BUCKET }} \
            --policy '{
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Sid": "PublicReadGetObject",
                        "Effect": "Allow",
                        "Principal": "*",
                        "Action": "s3:GetObject",
                        "Resource": "arn:aws:s3:::'${{ env.S3_BUCKET }}'/*"
                    }
                ]
            }'
          echo "‚úÖ Bucket policy set for public read access"
        else
          echo "‚ö†Ô∏è Bucket has public access blocked. Manual configuration required in AWS Console."
          echo "Please enable public read access in S3 Console for bucket: ${{ env.S3_BUCKET }}"
        fi
        
        # Sync static files to S3
        aws s3 sync out/ s3://${{ env.S3_BUCKET }}/ \
          --delete \
          --cache-control "max-age=31536000,public" \
          --exclude "*.html" \
          --exclude "*.json" \
          --exclude "*.xml"
        
        # Sync HTML, JSON, and XML files with no-cache
        aws s3 sync out/ s3://${{ env.S3_BUCKET }}/ \
          --delete \
          --cache-control "no-cache,no-store,must-revalidate" \
          --include "*.html" \
          --include "*.json" \
          --include "*.xml"
          
    - name: Setup CloudFront distribution
      run: |
        # Check if CloudFront distribution already exists
        EXISTING_DISTRIBUTION=$(aws cloudfront list-distributions \
          --query "DistributionList.Items[?Aliases.Items[?contains(@, '${{ env.FULL_DOMAIN }}')]].Id" \
          --output text)
        
        if [ "$EXISTING_DISTRIBUTION" = "None" ] || [ -z "$EXISTING_DISTRIBUTION" ]; then
          # Create new CloudFront distribution
          DISTRIBUTION_CONFIG=$(aws cloudfront create-distribution \
            --distribution-config '{
                "CallerReference": "'$(date +%s)'",
                "Comment": "Card Game Study Guide - '${{ env.FULL_DOMAIN }}'",
                "DefaultRootObject": "index.html",
                "Origins": {
                    "Quantity": 1,
                    "Items": [
                        {
                            "Id": "S3-'${{ env.S3_BUCKET }}'",
                            "DomainName": "'${{ env.S3_BUCKET }}'.s3.amazonaws.com",
                            "S3OriginConfig": {
                                "OriginAccessIdentity": ""
                            }
                        }
                    ]
                },
                "DefaultCacheBehavior": {
                    "TargetOriginId": "S3-'${{ env.S3_BUCKET }}'",
                    "ViewerProtocolPolicy": "redirect-to-https",
                    "TrustedSigners": {
                        "Enabled": false,
                        "Quantity": 0
                    },
                    "ForwardedValues": {
                        "QueryString": false,
                        "Cookies": {"Forward": "none"}
                    },
                    "MinTTL": 0,
                    "Compress": true
                },
                "Aliases": {
                    "Quantity": 1,
                    "Items": ["'${{ env.FULL_DOMAIN }}'"]
                },
                "Enabled": true,
                "PriceClass": "PriceClass_100"
            }' --output json)
          
          CLOUDFRONT_DISTRIBUTION_ID=$(echo "$DISTRIBUTION_CONFIG" | jq -r '.Distribution.Id')
          echo "CLOUDFRONT_DISTRIBUTION_ID=$CLOUDFRONT_DISTRIBUTION_ID" >> $GITHUB_ENV
        else
          echo "CLOUDFRONT_DISTRIBUTION_ID=$EXISTING_DISTRIBUTION" >> $GITHUB_ENV
        fi
        
    - name: Configure DNS records
      run: |
        # Get the hosted zone ID for the domain
        HOSTED_ZONE_ID=$(aws route53 list-hosted-zones \
          --query "HostedZones[?Name=='${{ env.DOMAIN }}.'].Id" \
          --output text)
        
        # Remove the trailing slash from hosted zone ID
        HOSTED_ZONE_ID=${HOSTED_ZONE_ID%/}
        
        # Get CloudFront distribution domain name
        CLOUDFRONT_DOMAIN=$(aws cloudfront get-distribution \
          --id ${{ env.CLOUDFRONT_DISTRIBUTION_ID }} \
          --query "Distribution.DomainName" \
          --output text)
        
        # Create A record alias to CloudFront
        aws route53 change-resource-record-sets \
          --hosted-zone-id "$HOSTED_ZONE_ID" \
          --change-batch '{
              "Changes": [
                  {
                      "Action": "UPSERT",
                      "ResourceRecordSet": {
                          "Name": "'${{ env.FULL_DOMAIN }}'",
                          "Type": "A",
                          "AliasTarget": {
                              "HostedZoneId": "Z2FDTNDATAQYW2",
                              "DNSName": "'$CLOUDFRONT_DOMAIN'",
                              "EvaluateTargetHealth": false
                          }
                      }
                  }
              ]
          }'
          
    - name: Invalidate CloudFront cache
      run: |
        aws cloudfront create-invalidation \
          --distribution-id ${{ env.CLOUDFRONT_DISTRIBUTION_ID }} \
          --paths "/*"
          
    - name: Deployment summary
      run: |
        echo "üöÄ Deployment completed successfully!"
        echo "üåê Your application is available at: https://${{ env.FULL_DOMAIN }}"
        echo "‚òÅÔ∏è CloudFront distribution ID: ${{ env.CLOUDFRONT_DISTRIBUTION_ID }}"
        echo "‚ö†Ô∏è Note: DNS changes may take up to 48 hours to propagate globally"
